use std::sync::RwLockWriteGuard;
use std::iter::FromIterator;
use std::str::FromStr;

use ast;
use symbol::{Symbol, Interner, SymbolMap};
use error::error;

grammar(interner: &mut RwLockWriteGuard<Interner>);

extern {
    type Error = (usize, String);
}

pub(crate) File: ast::File = {
    <stmts:(<Stmt> ";")*> => ast::File { <> },
};

Stmt: ast::Stmt = {
    Bind => ast::Stmt::Bind(<>),
    Expr => ast::Stmt::Expr(<>),
};

Bind: ast::Bind = {
    "let" <name:Symbol> <ty:(":" <Ty>)?> "=" <val:Expr> => ast::Bind { <> },
};

Ty: ast::Ty = {
    FnTy => ast::Ty::Fn(Box::new(<>)),
    Ty1,
}

Ty1: ast::Ty = {
    Tuple<Ty> => ast::Ty::Tuple(<>),
    Map<Ty> => ast::Ty::Struct(<>),
    "i32" => ast::Ty::I32,
    "unit" => ast::Ty::Unit,
    "never" => ast::Ty::Never,
}

FnTy: ast::ty::Fn = {
    <domain:Ty1> "->" <range:Ty> => ast::ty::Fn { <> },
}

Expr: ast::Expr = {
    LitExpr => ast::Expr::Lit(<>),
    Scope<Stmt, BoxExpr> => ast::Expr::Scope(<>),
};

BoxExpr: Box<ast::Expr> = Expr => Box::new(<>);

LitExpr: ast::expr::Lit = {
    <l:@L> <i:Int> =>? i32::from_str(i)
        .map(ast::expr::Lit::Int)
        .map_err(|err| error(l, err)),
    Map<Expr> => ast::expr::Lit::Struct(<>),
}

Scope<B, T>: ast::Scope<B, T> = {
    "(" <body:(<B> ";")*> <tail:T?> ")" => ast::Scope { <> },
};

Tuple<T>: ast::Tuple<T> = {
    "[" <init:(<T> ",")*> <tail:T?> "]" => {
        let mut val = init;
        val.extend(tail);
        ast::Tuple(val)
    }
}

Map<T>: ast::Map<T> = {
    "{" <init:(<Symbol> ":" <T> ",")*> <tail:(<Symbol> ":" <T>)?> "}" => {
        ast::Map(SymbolMap::from_iter(init.into_iter().chain(tail)))
    }
}

pub(crate) Symbol: Symbol = {
    OkSymbol => interner.intern(<>),
    <@L> BadSymbol =>? Err(error(<>, "symbol may not contain consecutive or trailing '_' characters")),
};

match { 
    // Keywords
    "sys",
    "read",
    "write",
    "comp",
    "type",
    "never",
    "unit",
    "i32",
    "struct",
    "enum",
    "let",
    // Punctuation
    ";", 
    ",",
    "=",
    ":",
    ".",
    "(",
    ")",
    "{",
    "}",
    "[",
    "]",
    "->",
} else { 
    // Valid symbol
    r"_?[[:alpha:]](?:_?[[:alnum:]])*" => OkSymbol,
} else {
    // Invalid symbol
    r"[_[:alpha:]][_[:word:]]*" => BadSymbol,
} else {
    // Integer literal
    r"[+-]?[[:digit:]]+" => Int,
}