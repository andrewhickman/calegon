use std::sync::RwLockWriteGuard;
use std::str::{FromStr};
use std::string::ToString;

use {ast, symbol};
use error::error;

grammar(interner: &mut RwLockWriteGuard<symbol::Interner>);

extern {
    type Error = (usize, String);
}

pub(crate) File: ast::File = {
    <items:(<Item> ";")*> => ast::File { <> }
}

pub(crate) Item: ast::Item = {
    Sys => ast::Item::Sys(<>),
    Comp => ast::Item::Comp(<>),
    TyDef => ast::Item::TyDef(<>),
}

pub(crate) Sys: ast::Sys = {
    "sys" <name:Symbol> "{" <stmts:(<Stmt> ";")*> "}" => ast::Sys { <> }
}

pub(crate) Stmt: ast::Stmt = {
    Item => ast::Stmt::Item(<>),
    Read => ast::Stmt::Read(<>),
    Write => ast::Stmt::Write(<>),
    Expr => ast::Stmt::Expr(<>),
    Binding => ast::Stmt::Binding(<>),
};

pub(crate) Read: ast::Read = {
    "read" <comps:Punctuated<Symbol, ",">> => ast::Read { <> }
};

pub(crate) Write: ast::Write = {
    "write" <comps:Punctuated<Symbol, ",">> => ast::Write { <> }
};

pub(crate) Comp: ast::Comp = {
    "comp" <name:Symbol> <ty:Ty> => ast::Comp { <> }
};

pub(crate) TyDef: ast::TyDef = {
    "type" <name:Symbol> <ty:Ty> => ast::TyDef { <> }
};

pub(crate) Ty: ast::Ty = {
    "never" => ast::Ty::Never,
    "unit" => ast::Ty::Unit,
    "i32" => ast::Ty::I32,
    Symbol => ast::Ty::TyDef(<>),
    Struct => ast::Ty::Struct(<>),
    Enum => ast::Ty::Enum(<>),
};

pub(crate) Struct: ast::Struct = {
    "struct" "{" <fields:Punctuated<(<Symbol> ":" <Ty>), ",">> "}" => ast::Struct { <> }
};

pub(crate) Enum: ast::Enum = {
    "enum" "{" <fields:Punctuated<(<Symbol> ":" <Ty>), ",">> "}" => ast::Enum { <> }
};

pub(crate) Binding: ast::Binding = {
    "let" <name:Symbol> <ty:(":" <Ty>)?> <val:("=" <Term>)?> => ast::Binding { <> }
};

pub(crate) Expr: ast::Expr = {
    DotTerm Term => ast::Expr::FnCall(<>),
    ScopeExpr,
}

ScopeExpr: ast::Expr = {
    "{" <(<Stmt> ";")*> <Term?> "}" => ast::Expr::Scope(<>),
}

pub(crate) Term: ast::Term = {
    <DotTerm> <Term> => ast::Term::Expr(Box::new(ast::Expr::FnCall(<>))),
    DotTerm,
}

DotTerm: ast::Term = {
    <term:DotTerm> "." <name:Symbol> => ast::Term::Dot(Box::new(term), name),
    <l:@L> <i:Int> =>? i32::from_str(i).map(ast::Term::Literal).map_err(|err| error(l, err)),
    "{" <PunctuatedNonEmpty<(<Symbol> ":" <Term>), ",">> "}" => ast::Term::Struct(<>),
    ScopeExpr => ast::Term::Expr(Box::new(<>)),
    Symbol => ast::Term::Var(<>),
}

pub(crate) Symbol: symbol::Symbol = {
    OkSymbol => interner.intern(<>),
    <@L> BadSymbol =>? Err(error(<>, "symbol may not contain consecutive or trailing '_' characters")),
};

// Common macros
Punctuated<T, P>: Vec<T> = {
    <values:(<T> P)*> <e:T?> => match e {
        None => values,
        Some(e) => {
            let mut values = values;
            values.push(e);
            values
        }
    }
};

// Common macros
PunctuatedNonEmpty<T, P>: Vec<T> = {
    <e:T> <values:(P <T>)*> P? => {
        let mut values = values;
        values.insert(0, e);
        values
    }
};

match { 
    // Keywords
    "sys",
    "read",
    "write",
    "comp",
    "type",
    "never",
    "unit",
    "i32",
    "struct",
    "enum",
    "let",
    // Punctuation
    ";", 
    ",",
    "=",
    ":",
    ".",
    r"[{(\[]" => "{", 
    r"[})\]]" => "}", 
} else { 
    // Valid symbol
    r"_?[[:alpha:]](?:_?[[:alnum:]])*" => OkSymbol,
} else {
    // Invalid symbol
    r"[_[:alpha:]][_[:word:]]*" => BadSymbol,
} else {
    // Integer literal
    r"[+-]?[[:digit:]]+" => Int,
}